#include "public.h"

//audio
#include <Audio.h>
// GUItool: begin automatically generated code
static AudioInputI2S i2s2;                      //xy=105,63
static AudioAnalyzePeak peak1;                  //xy=278,108
static AudioRecordQueue queue1;                 //xy=281,63
static AudioPlaySdRaw playRaw1;                 //xy=302,157
static AudioOutputI2S i2s1;                     //xy=470,120
static AudioConnection patchCord1(i2s2, 0, queue1, 0);
static AudioConnection patchCord2(i2s2, 0, peak1, 0);
static AudioConnection patchCord3(playRaw1, 0, i2s1, 0);
static AudioConnection patchCord4(playRaw1, 0, i2s1, 1);
static AudioControlSGTL5000 sgtl5000_1;         //xy=265,212
// GUItool: end automatically generated code
static const int audioIn = AUDIO_INPUT_MIC;

//a file i/f
#include <SdFat.h>
File file;

void __audio_setup() {
  // Audio connections require memory, and the record queue
  // uses this memory to buffer incoming audio.
  //AudioMemory(60);
  AudioMemory(350);
  // well.. buffer overrun prob. happens..
  //    --> https://forum.pjrc.com/threads/52127-Bits-of-audio-missing-from-recordings?p=178535&viewfull=1#post178535
  //    --> https://forum.pjrc.com/threads/52175-Audio-Recording-Logging-to-SD-card-gt-microSoundRecorder
  //    --> https://forum.pjrc.com/threads/46136-Yet-another-SimpleAudioLogger

  // Enable the audio shield, select input, and enable output
  sgtl5000_1.enable();
  sgtl5000_1.inputSelect(audioIn);
  sgtl5000_1.volume(0.5);
}

void __audio_start_playing() {
  Serial.println("startPlaying");
  playRaw1.play(__filenameNowHere.c_str());
  mode = 2;
}

void __audio_continue_playing() {
  if (!playRaw1.isPlaying()) {
    playRaw1.stop();
    mode = 0;
  }
}

void __audio_stop_playing() {
  Serial.println("stopPlaying");
  if (mode == 2) playRaw1.stop();
  mode = 0;
}

void __audio_start_recording() {
  Serial.println("startRecording");
  // if (SD.exists("RECORD.RAW")) {
  //   // The SD library writes new data to the end of the
  //   // file, so to start a new recording, the old file
  //   // must be deleted before new data is written.
  //   SD.remove("RECORD.RAW");
  // }
  // frec = SD.open("RECORD.RAW", FILE_WRITE);
  // if (frec) {
  //   queue1.begin();
  //   mode = 1;
  // }

  //from 'src/FatLib/FatApiConstants.h' of SdFat library
  // /** open() oflag for reading */
  // const uint8_t O_READ = 0X01;
  // /** open() oflag - same as O_IN */
  // const uint8_t O_RDONLY = O_READ;
  // /** open() oflag for write */
  // const uint8_t O_WRITE = 0X02;
  // /** open() oflag - same as O_WRITE */
  // const uint8_t O_WRONLY = O_WRITE;
  // /** open() oflag for reading and writing */
  // const uint8_t O_RDWR = (O_READ | O_WRITE);
  // /** open() oflag mask for access modes */
  // const uint8_t O_ACCMODE = (O_READ | O_WRITE);
  // /** The file offset shall be set to the end of the file prior to each write. */
  // const uint8_t O_APPEND = 0X04;
  // /** synchronous writes - call sync() after each write */
  // const uint8_t O_SYNC = 0X08;
  // /** truncate the file to zero length */
  // const uint8_t O_TRUNC = 0X10;
  // /** set the initial position at the end of the file */
  // const uint8_t O_AT_END = 0X20;
  // /** create the file if nonexistent */
  // const uint8_t O_CREAT = 0X40;
  // /** If O_CREAT and O_EXCL are set, open() shall fail if the file exists */
  // const uint8_t O_EXCL = 0X80;

  // so.. maybe..
  //  --> O_WRITE | O_SYNC | O_TRUNC | O_CREAT | O_EXCL
  //  --> if there's a file already.. then do nothing.
  //  --> open a new file if there's no such file
  //  --> then, trucate to 0 (so existing data will be gone. / but this is confusing cause we have O_EXCL)
  //  --> every write will also sync

  // so.. overwriting to one file for tests
  //  --> O_WRITE | O_SYNC | O_TRUNC | O_CREAT

  // so.. not allowing overwriting and always create new file for normal operation.
  //  --> O_WRITE | O_SYNC | O_CREAT | O_EXCL
  //  or
  //  --> O_WRITE | O_SYNC | O_TRUNC | O_CREAT | O_EXCL
  //  (although, this doesn't make a good sense, since this file will be always a newly created one..)

  //
  __syncFilenameNowHere();
  //
  if (!file.open(__filenameNowHere.c_str(), O_RDWR | O_CREAT)) {
    sdEx.errorHalt("open failed");
    return;
  }
  else {
    file.truncate(0);
    queue1.begin();
    mode = 1;
  }
}

void __audio_continue_recording() {
  if (queue1.available() >= 2) {
    byte buffer[512];
    memcpy(buffer, queue1.readBuffer(), 256);
    queue1.freeBuffer();
    memcpy(buffer+256, queue1.readBuffer(), 256);
    queue1.freeBuffer();
    // write all 512 bytes to the SD card

    // Uncomment these lines to see how long SD writes
    // are taking.  A pair of audio blocks arrives every
    // 5802 microseconds, so hopefully most of the writes
    // take well under 5802 us.  Some will take more, as
    // the SD library also must write to the FAT tables
    // and the SD card controller manages media erase and
    // wear leveling.  The queue1 object can buffer
    // approximately 301700 us of audio, to allow time
    // for occasional high SD card latency, as long as
    // the average write time is under 5802 us.
    // Serial.print("SD write, us=");
    // Serial.println(usec);

    //DEBUG: profiling
    looptime_sdwr = 0;
    if (512 != file.write(buffer, 512)) {
      sdEx.errorHalt("write failed");
    }
    display->print("sdwr : "); display->print(looptime_sdwr/1000000.0, 6); display->println(" sec.");
  }
}

void __audio_stop_recording() {
  Serial.println("stopRecording");
  queue1.end();
  if (mode == 1) {
    while (queue1.available() > 0) {
      if (256 != file.write((byte*)queue1.readBuffer(), 256)) {
        sdEx.errorHalt("write failed");
      }
      queue1.freeBuffer();
    }
    file.close();
  }
  mode = 0;

  //list
  if (!dirFile.open("/", O_READ)) {
    sdEx.errorHalt("open root failed");
  }
  uint16_t n = 0;
  const uint16_t nMax = 10;
  uint16_t dirIndex[nMax];
  while (n < nMax && file.openNext(&dirFile, O_READ)) {

    // Skip directories and hidden files.
    if (!file.isSubDir() && !file.isHidden()) {

      // Save dirIndex of file in directory.
      dirIndex[n] = file.dirIndex();

      // Print the file number and name.
      Serial.print(n++);
      Serial.write(' ');
      file.printName(&Serial);
      Serial.println();
    }
    file.close();
  }
  dirFile.close();
}

void __audio_adjust_mic_level() {
  // when using a microphone, continuously adjust gain
  if (audioIn == AUDIO_INPUT_MIC) {
    // TODO: read the peak1 object and adjust sgtl5000_1.micGain()
    // if anyone gets this working, please submit a github pull request :-)
  }
}
